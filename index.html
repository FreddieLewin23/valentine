<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Valentine</title>
  <style>
    :root { --pink:#ff5fa2; }
    body{
      margin:0; height:100vh; display:flex; align-items:center; justify-content:center;
      background:#fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      overflow:hidden;
    }
    .card{
      width:min(520px, 92vw);
      border:4px solid var(--pink);
      border-radius:18px;
      padding:34px 26px;
      text-align:center;
      background:#ffe6f1;
      box-shadow: 0 10px 30px rgba(0,0,0,.08);
      position:relative;
    }
    h1{ margin:0 0 22px; color:#b4004e; font-size:32px; }
    .btns{
      position:relative;
      height:120px;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:18px;
      overflow:hidden;
    }
    button{
      font-size:18px;
      padding:12px 22px;
      border-radius:12px;
      cursor:pointer;
      user-select:none;
    }
    #yes{
      background: var(--pink);
      color:#fff;
      border:0;
    }
    #no{
      background:#fff;
      color:#b4004e;
      border:2px solid #ff9ac6;
      position:absolute;
      left:0;
      top:0;
      will-change: left, top;
    }
    .huzzah{
      font-size:56px;
      color: var(--pink);
      font-weight:800;
      letter-spacing: 0.5px;
    }

    /* Confetti */
    .confetti {
      position: fixed;
      top: -20px;
      left: 0;
      width: 10px;
      height: 16px;
      border-radius: 2px;
      z-index: 9999;
      pointer-events: none;
      opacity: 0.95;
      animation-name: confetti-fall;
      animation-timing-function: linear;
      animation-fill-mode: forwards;
    }
    @keyframes confetti-fall {
      0%   { transform: translate3d(var(--x), -20px, 0) rotate(0deg); }
      100% { transform: translate3d(calc(var(--x) + var(--drift)), calc(100vh + 120px), 0) rotate(var(--rot)); }
    }
  </style>
</head>
<body>
  <div class="card" id="card">
    <h1>Will you be my valentine?</h1>

    <div class="btns" id="arena">
      <button id="yes" type="button">Yes</button>
      <button id="no" type="button">No</button>
    </div>
  </div>

  <script>
    (() => {
      const arena = document.getElementById("arena");
      const noBtn = document.getElementById("no");
      const yesBtn = document.getElementById("yes");
      const card  = document.getElementById("card");

      // Arena and button dimensions (cached, in px)
      let aw = 0, ah = 0, bw = 0, bh = 0;

      // No button position + velocity in arena coordinates (top-left)
      let x = 0, y = 0;
      let vx = 0, vy = 0;

      // Mouse in arena coordinates
      let mx = null, my = null;

      let running = true;
      let lastT = null;

      function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

      function measure() {
        // Use offsetWidth/Height to avoid layout jitter from getBoundingClientRect per frame
        aw = arena.clientWidth;
        ah = arena.clientHeight;
        bw = noBtn.offsetWidth;
        bh = noBtn.offsetHeight;
      }

      function setPos(nx, ny) {
        x = nx; y = ny;
        noBtn.style.left = `${x}px`;
        noBtn.style.top  = `${y}px`;
      }

      function initPos() {
        measure();
        setPos((aw - bw) / 2, (ah - bh) / 2);
        vx = 0; vy = 0;
      }

      function updateMouseFromClient(clientX, clientY) {
        const r = arena.getBoundingClientRect();
        mx = clientX - r.left;
        my = clientY - r.top;
      }

      arena.addEventListener("mousemove", (e) => updateMouseFromClient(e.clientX, e.clientY), { passive: true });
      arena.addEventListener("touchmove", (e) => {
        const t = e.touches[0];
        updateMouseFromClient(t.clientX, t.clientY);
      }, { passive: true });

      // Smooth local flee: no bouncing, no teleporting
      function tick(t) {
        if (!running) return;

        if (lastT === null) lastT = t;
        const dt = clamp((t - lastT) / 1000, 0, 0.025);
        lastT = t;

        // Keep measurements fresh if fonts render differently, etc.
        measure();

        const minX = 0, minY = 0;
        const maxX = Math.max(0, aw - bw);
        const maxY = Math.max(0, ah - bh);

        // Button center in arena coords
        const cx = x + bw / 2;
        const cy = y + bh / 2;

        // Steering parameters
        const panicRadius = 120;     // reacts when mouse closer than this
        const maxSpeed = 120;        // px/s (kept low so it never rockets away)
        const accel = 900;           // px/s^2
        const damping = 12;          // velocity smoothing
        const maxStep = 5;           // px per frame hard cap (prevents big jumps)

        let targetVx = 0, targetVy = 0;

        if (mx !== null && my !== null) {
          const dx = cx - mx;
          const dy = cy - my;
          const dist = Math.hypot(dx, dy) || 1;

          if (dist < panicRadius) {
            // Smooth ramp: small movement unless very close
            const s = (panicRadius - dist) / panicRadius; // 0..1
            const strength = s * s; // gentle until close

            const ux = dx / dist;
            const uy = dy / dist;

            // Desired speed increases with closeness, but stays local
            const desiredSpeed = maxSpeed * strength;

            targetVx = ux * desiredSpeed;
            targetVy = uy * desiredSpeed;
          }
        }

        // Move velocity toward target velocity smoothly
        const dvx = targetVx - vx;
        const dvy = targetVy - vy;

        // Acceleration limit
        const maxDv = accel * dt;
        const dvmag = Math.hypot(dvx, dvy) || 1;
        const scale = dvmag > maxDv ? (maxDv / dvmag) : 1;

        vx += dvx * scale;
        vy += dvy * scale;

        // Damping toward zero when not fleeing
        vx -= vx * damping * dt * 0.35;
        vy -= vy * damping * dt * 0.35;

        // Integrate, but cap per-frame movement
        let dxStep = vx * dt;
        let dyStep = vy * dt;

        const stepMag = Math.hypot(dxStep, dyStep) || 1;
        if (stepMag > maxStep) {
          dxStep = (dxStep / stepMag) * maxStep;
          dyStep = (dyStep / stepMag) * maxStep;
        }

        let nx = x + dxStep;
        let ny = y + dyStep;

        // Clamp to bounds, and ZERO velocity on the axis that hits the wall
        if (nx < minX) { nx = minX; vx = 0; }
        if (nx > maxX) { nx = maxX; vx = 0; }
        if (ny < minY) { ny = minY; vy = 0; }
        if (ny > maxY) { ny = maxY; vy = 0; }

        setPos(nx, ny);

        requestAnimationFrame(tick);
      }

      function launchConfetti() {
        const colors = ["#ff5fa2", "#ffd1e6", "#ffffff", "#ff9ac6"];
        const count = 200;

        for (let i = 0; i < count; i++) {
          const c = document.createElement("div");
          c.className = "confetti";

          const xvw = Math.random() * 100;
          const driftPx = (Math.random() - 0.5) * 360;
          const rotDeg = (Math.random() * 900 + 360) * (Math.random() < 0.5 ? -1 : 1);
          const dur = 1200 + Math.random() * 1200;

          c.style.background = colors[Math.floor(Math.random() * colors.length)];
          c.style.setProperty("--x", xvw + "vw");
          c.style.setProperty("--drift", driftPx + "px");
          c.style.setProperty("--rot", rotDeg + "deg");
          c.style.animationDuration = dur + "ms";
          c.style.animationDelay = (Math.random() * 200) + "ms";

          const w = 6 + Math.random() * 6;
          const h = 10 + Math.random() * 10;
          c.style.width = w + "px";
          c.style.height = h + "px";

          document.body.appendChild(c);
          c.addEventListener("animationend", () => c.remove());
        }
      }

      yesBtn.addEventListener("click", () => {
        running = false;
        card.remove();

        const h = document.createElement("div");
        h.className = "huzzah";
        h.textContent = "huzzah!";
        document.body.appendChild(h);

        launchConfetti();
      });

      window.addEventListener("resize", initPos);

      initPos();
      requestAnimationFrame(tick);
    })();
  </script>
</body>
</html>




